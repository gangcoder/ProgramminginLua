<html>

<head>
  <title>29.2 XML解析 - Lua程序设计</title>
  <meta http-equiv=Content-Type content="text/html; charset=UTF-8">
  <meta name="GENERATOR" content="Macrobject Word-2-CHM">
  <link rel="stylesheet" href="Word2Chm.css" type="text/css">
  <link rel="stylesheet" href="default.css" type="text/css" />
</head>

<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="moHeader">&nbsp;29.2 XML解析</td>
    </tr>
  </table>
  
  <p></p>

<div class=Section1 style='layout-grid:15.6pt'>



<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>现在，我们将要看到一个</span><span
lang=EN-US>xml</span><span style='font-family:宋体'>解析器的简单实现，称为</span><span
lang=EN-US>lxp<a href="#_ftn10" name="_ftnref10" title=""><span
class=MsoFootnoteReference><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:10.5pt;font-family:"Times New Roman","serif"'>[10]</span></span></span></a></span><span
style='font-family:宋体'>，它包括了</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>和</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>（</span><span lang=EN-US><a
href="http://www.libexpat.org/">http://www.libexpat.org/</a></span><span
style='font-family:宋体'>）。</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>是一个开源的</span><span lang=EN-US>C</span><span
style='font-family:宋体'>语言写成的</span><span lang=EN-US>XML 1.0</span><span
style='font-family:宋体'>的解析器。它实现了</span><span lang=EN-US>SAX</span><span
style='font-family:宋体'>（</span><span lang=EN-US><a
href="http://www.saxproject.org/">http://www.saxproject.org/</a></span><span
style='font-family:宋体'>），</span><span lang=EN-US>SAX</span><span
style='font-family:宋体'>是</span><span lang=EN-US>XML</span><span
style='font-family:宋体'>简单的</span><span lang=EN-US>API</span><span
style='font-family:宋体'>，是基于事件的</span><span lang=EN-US>API</span><span
style='font-family:宋体'>，这意味着一个</span><span lang=EN-US>SAX</span><span
style='font-family:宋体'>解析器读取有一个</span><span lang=EN-US>XML</span><span
style='font-family:宋体'>文档，然后反馈给应用程序他所发现的。举个例子，我们要通知</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>解析这样一个字符串：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(243,242,236)'><span
lang=EN-US>&lt;tag cap=<span style='color:red'>&quot;5&quot;</span>&gt;hi&lt;/tag&gt;</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>它将会产生三个事件：当它读取子字符串</span><span
lang=EN-US> &quot;&lt;tag cap=&quot;5&quot;&gt;hi&lt;/tag&gt;&quot;</span><span
style='font-family:宋体'>，产生一个读取到开始元素的事件；当它解析</span><span lang=EN-US>
&quot;hi&quot; </span><span style='font-family:宋体'>时，产生一个读取文本事件（有时也称为字符数据事件）；当解析</span><span
lang=EN-US> &quot;end&quot; </span><span style='font-family:宋体'>时，产生一个读取结束元素的事件。而每个事件，都会调用应用程序适当的句柄。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>这里我们不会涉及到整个</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>库，我们只会集中精力关注那些能够阐明和</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>相互作用的新技术的部分。当我们实现了核心功能后，在上面进行扩展将会变得很容易。虽然</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>解析</span><span lang=EN-US>XML</span><span
style='font-family:宋体'>文档时会有很多事件，我们将会关心的仅仅是上面例子提到的三个事件（开始元素，结束元素，文本数据），我们需要调用的</span><span
lang=EN-US>API</span><span style='font-family:宋体'>是</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>众多</span><span lang=EN-US>API</span><span
style='font-family:宋体'>中很少的几个。首先，我们需要创建和析构</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>解析器的函数：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(229,234,220)'><span
lang=EN-US style='color:blue'>#include</span><span lang=EN-US>
&lt;xmlparse.h&gt;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(234,252,250)'><span
lang=EN-US>XML_Parser XML_ParserCreate (<span style='color:blue'>const</span> <span
style='color:blue'>char</span> *encoding);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> XML_ParserFree
(XML_Parser p);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>这里函数参数是可选的；在我们的使用中，我们直接选用</span><span
lang=EN-US>NULL</span><span style='font-family:宋体'>作为参数。当我们有了一个解析器的时候，我们必须注册回调的句柄：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(223,232,241);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>XML_SetElementHandler(XML_Parser p,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(236,255,236)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;XML_StartElementHandler
start,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;XML_EndElementHandler
end);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(228,226,231)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>XML_SetCharacterDataHandler(XML_Parser p,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(238,224,237)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XML_CharacterDataHandler
hndl);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>第一个函数登记了开始元素和结束元素的句柄。第二个函数登记了文本数据（在</span><span
lang=EN-US>XML</span><span style='font-family:宋体'>语法中的字符数据）的句柄。所有回掉的句柄通过第一个参数接收用户数据。开始元素的句柄同样接收到标签的名称和它的属性作为参数：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(224,245,225)'><span
lang=EN-US style='color:blue'>typedef</span><span lang=EN-US> <span
style='color:blue'>void</span> (*XML_StartElementHandler)(<span
style='color:blue'>void</span> *uData,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;
<span style='color:blue'>const</span> <span style='color:blue'>char</span>
*name,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(232,222,247)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
<span style='color:blue'>const</span> <span style='color:blue'>char</span>
**atts);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>这些属性来自于以</span><span
lang=EN-US> '\0' </span><span style='font-family:宋体'>结束的字符串组成的数组，这些字符串分别对应了一对以属性名和属性值组成的属性。结束元素的句柄只有一个参数，就是标签名。</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(242,229,226)'><span
lang=EN-US style='color:blue'>typedef</span><span lang=EN-US> <span
style='color:blue'>void</span> (*XML_EndElementHandler)(<span style='color:
blue'>void</span> *uData,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:blue'>const</span> <span style='color:blue'>char</span> *name)</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>最终，一个文本句柄仅仅以字符串作为额外的参数。该文本字符串不能是以</span><span
lang=EN-US>'\0'</span><span style='font-family:宋体'>结束的字符串，而是显式指明长度的字符串：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(252,234,225);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>typedef</span><span lang=EN-US> <span
style='color:blue'>void</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,249,250)'><span
lang=EN-US>(*XML_CharacterDataHandler)(<span style='color:blue'>void</span>
*uData,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:blue'>const</span> <span style='color:blue'>char</span> *s,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,251,246)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:blue'>int</span> len);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>我们用下面的函数将这些文本传给</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(247,232,224)'><span
lang=EN-US style='color:blue'>int</span><span lang=EN-US> XML_Parse (XML_Parser
p,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span
style='color:blue'>const</span> <span style='color:blue'>char</span> *s, <span
style='color:blue'>int</span> len, <span style='color:blue'>int</span>
isFinal);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>Expat</span><span
style='font-family:宋体'>通过成功调用</span><span lang=EN-US>XML_Parse</span><span
style='font-family:宋体'>一段一段的解析它接收到的文本。</span><span lang=EN-US>XML_Parse</span><span
style='font-family:宋体'>最后一个参数为</span><span lang=EN-US>isFinal</span><span
style='font-family:宋体'>，他表示这部分是不是</span><span lang=EN-US>XML</span><span
style='font-family:宋体'>文档的最后一个部分了。需要注意的是不是每段文本都需要通过</span><span lang=EN-US>0</span><span
style='font-family:宋体'>来表示结束，我们也可以通过显实的长度来判定。</span><span lang=EN-US>XML_Parse</span><span
style='font-family:宋体'>函数如果发现解析错误就会返回一个</span><span lang=EN-US>0</span><span
style='font-family:宋体'>（</span><span lang=EN-US>expat</span><span
style='font-family:宋体'>也提供了辅助的函数来显示错误信息，但是因为简单的缘故，我们这里都将之忽略掉）。我们需要</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>的最后一个函数是允许我们设置将要传给句柄的用户数据的函数：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(234,238,221);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>void</span><span lang=EN-US> XML_SetUserData
(XML_Parser p, <span style='color:blue'>void</span> *uData);</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>好了，现在我们来看一下如何在</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>中使用</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>库。第一种方法也是最直接的一种方法：简单的在</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>中导入这些函数。比较好的方法是对</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>调整这些函数。比如</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>是没有类型的，我们不需要用不同的函数来设置不同的调用。但是我们怎么样避免一起调用那些注册了的函数呢。替代的是，当我们创建了一个解析器，我们同时给出了一个包含所有回调句柄以及相应的键值的回调表。举个例子来说，如果我们要打印一个文档的布局，我们可以用下面的回调表：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(254,221,253);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>local count = 0</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(242,254,231)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>callbacks = {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(233,239,227)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; StartElement = function (parser, tagname)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io.write(<span
style='color:red'>&quot;+ &quot;</span>, string.rep(<span style='color:red'>&quot;&nbsp;
&quot;</span>, count), tagname, <span style='color:red'>&quot;\n&quot;</span>)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(237,245,248)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = count + 1</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; end,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(230,230,228)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; EndElement = function (parser, tagname)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(248,231,252)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = count - 1</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io.write(<span
style='color:red'>&quot;- &quot;</span>, string.rep(<span style='color:red'>&quot;&nbsp;
&quot;</span>, count), tagname, <span style='color:red'>&quot;\n&quot;</span>)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(248,240,252)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; end,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>输入</span><span
lang=EN-US>&quot;&lt;to&gt; &lt;yes/&gt; &lt;/to&gt;&quot;</span><span
style='font-family:宋体'>，这些句柄将会打印出：</span></p>

<div style='border:dashed windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(221,247,239);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>+ to</span></p>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:RGB(224,254,255)'><span
lang=EN-US>+&nbsp;&nbsp; yes</span></p>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>-&nbsp;&nbsp; yes</span></p>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:RGB(245,239,233)'><span
lang=EN-US>- to</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>通过这个</span><span
lang=EN-US>API</span><span style='font-family:宋体'>，我们不需要维护这些函数的调用。我们直接在回调表中维回他们。因此，整个</span><span
lang=EN-US>API</span><span style='font-family:宋体'>需要三个函数：一个创建解析器，一个解析一段段文本，最后一个关闭解析器。（实际上，我们用解析器对象的方法，实现了最后两个功能）。对这些</span><span
lang=EN-US>API</span><span style='font-family:宋体'>函数的典型使用如下：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(248,238,230)'><span
lang=EN-US>p = lxp.new(callbacks)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:green'>-- create new parser</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>for</span><span lang=EN-US> l <span
style='color:blue'>in</span> io.lines() <span style='color:blue'>do</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:green'>-- iterate over input lines</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(236,220,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; assert(p:parse(l))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:green'>-- parse the line</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; assert(p:parse(<span style='color:red'>&quot;\n&quot;</span>))&nbsp;&nbsp;&nbsp; <span
style='color:green'>-- add a newline</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(254,255,220)'><span
lang=EN-US style='color:blue'>end</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>assert(p:parse())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:green'>-- finish document</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(237,242,225)'><span
lang=EN-US>p:close()</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>现在，让我们把注意力集中到实现中来。首先，考虑如何在</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>中实现解析器。很自然的会想到使用</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>，但是我们将什么内容放在</span><span
lang=EN-US>userdata</span><span style='font-family:宋体'>里呢？至少，我们必须保留实际的</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>解析器和一个回调表。我们不能将一个</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>表保存在一个</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>（或者在任何的</span><span
lang=EN-US>C</span><span style='font-family:宋体'>结构中），然而，我们可以创建一个指向表的引用，并将这个引用保存在</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>中。（我们在</span><span
lang=EN-US>27.3.2</span><span style='font-family:宋体'>节已经说过，一个引用就是</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>自动产生的在</span><span
lang=EN-US>registry</span><span style='font-family:宋体'>中的一个整数）最后，我们还必须能够将</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>的状态保存到一个解析器对象中，因为这些解析器对象就是</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>回调从我们程序中接受的所有内容，并且这些回调需要调用</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>。一个解析器的对象的定义如下：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(242,223,252)'><span
lang=EN-US style='color:blue'>#include</span><span lang=EN-US>
&lt;xmlparse.h&gt;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(244,227,227)'><span
lang=EN-US style='color:blue'>typedef</span><span lang=EN-US> <span
style='color:blue'>struct</span> lxp_userdata {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_State *L;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(250,247,240)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; XML_Parser *parser;&nbsp; <span style='color:
green'>/* associated expat parser */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>int</span> tableref; <span
style='color:green'>/* table with callbacks for this parser */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(250,223,225)'><span
lang=EN-US>} lxp_userdata;</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>下面是创建解析器对象的函数：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,235,246)'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>int</span> lxp_make_parser (lua_State *L) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; XML_Parser p;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(222,241,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(232,226,236)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* (1) create a parser
object */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu = (lxp_userdata *)lua_newuserdata(L,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(251,220,248)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:blue'>sizeof</span>(lxp_userdata));</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(236,226,232)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* pre-initialize it,
in case of errors */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;tableref = LUA_REFNIL;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,220,231)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;parser = NULL;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(235,244,253)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* set its metatable */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_getmetatable(L, <span style='color:red'>&quot;Expat&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(229,251,253)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_setmetatable(L, -2);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,238,247)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* (2) create the Expat
parser */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; p = xpu-&gt;parser = XML_ParserCreate(NULL);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(238,245,255)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>if</span> (!p)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; luaL_error(L, <span
style='color:red'>&quot;XML_ParserCreate failed&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(244,224,248)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* (3) create and store
reference to callback table */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(226,246,220)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_checktype(L, 1, LUA_TTABLE);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushvalue(L, 1);&nbsp; <span
style='color:green'>/* put table on the stack top */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(241,222,238)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;tableref = luaL_ref(L,
LUA_REGISTRYINDEX);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,237,223)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* (4) configure Expat
parser */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; XML_SetUserData(p, xpu);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,254,230)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; XML_SetElementHandler(p, f_StartElement,
f_EndElement);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; XML_SetCharacterDataHandler(p, f_CharData);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(229,223,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span> 1;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>函数</span><span
lang=EN-US>lxp_make_parser</span><span style='font-family:宋体'>有四个主要步骤：</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>第一步遵循共同的模式：首先创建一个</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>，然后使用</span><span
lang=EN-US>consistent</span><span style='font-family:宋体'>的值预初始化</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>，最后设置</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>的</span><span
lang=EN-US>metatable</span><span style='font-family:宋体'>。预初始化的原因在于：如果在初始化的时候有任何错误的话，我们必须保证析构器（</span><span
lang=EN-US>__gc</span><span style='font-family:宋体'>元方法）能够发现在可靠状态下发现</span><span
lang=EN-US>userdata</span><span style='font-family:宋体'>并释放资源。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>第二步，函数创建一个</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>解析器，将它保存在</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>中，并检测错误。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>第三步，保证函数的第一个参数是一个表（回调表），创建一个指向表的引用，并将这个引用保存到新的</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>中。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>第四步，初始化</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>解析器，将</span><span
lang=EN-US>userdatum</span><span style='font-family:宋体'>设置为将要传递给回调函数的对象，并设置这些回调函数。注意，对于所有的解析器来说这些回调函数都一样。毕竟，在</span><span
lang=EN-US>C</span><span style='font-family:宋体'>中不可能动态的创建新的函数，取代的方法是，这些固定的</span><span
lang=EN-US>C</span><span style='font-family:宋体'>函数使用回调表来决定每次应该调用哪个</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>函数。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>下一步是解析方法，负责解析一段</span><span
lang=EN-US>XML</span><span style='font-family:宋体'>数据。他有两个参数：解析器对象</span><span
lang=EN-US>(</span><span style='font-family:宋体'>方法自己</span><span lang=EN-US>)</span><span
style='font-family:宋体'>和一个可选的一段</span><span lang=EN-US>XML</span><span
style='font-family:宋体'>数据。当没有数据调用这个方法时，他通知</span><span lang=EN-US>Expat</span><span
style='font-family:宋体'>文档已经解析结束：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(234,220,242);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>int</span> lxp_parse (lua_State *L) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,241,231)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>int</span> status;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; size_t len;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(228,222,229)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>const</span> <span
style='color:blue'>char</span> *s;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(243,221,225)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* get and check first
argument (should be a parser) */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(228,220,242)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu = (lxp_userdata *)luaL_checkudata(L, 1, <span
style='color:red'>&quot;Expat&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_argcheck(L, xpu, 1, <span style='color:red'>&quot;expat
parser expected&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(255,250,249)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* get second argument
(a string) */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,251,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; s = luaL_optlstring(L, 2, NULL, &amp;len);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(221,221,237)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* prepare environment
for handlers: */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* put callback table
at stack index 3 */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,227,240)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_settop(L, 2);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_getref(L, xpu-&gt;tableref);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(221,238,227)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;L = L;&nbsp; <span style='color:green'>/*
set Lua state */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(228,229,225)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* call Expat to parse
string */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; status = XML_Parse(xpu-&gt;parser, s, (<span
style='color:blue'>int</span>)len, s == NULL);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(240,226,233)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* return error code */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(243,229,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushboolean(L, status);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span> 1;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,232,245)'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>当</span><span
lang=EN-US>lxp_parse</span><span style='font-family:宋体'>调用</span><span
lang=EN-US>XML_Parse</span><span style='font-family:宋体'>的时候，后一个函数将会对在给定的一段</span><span
lang=EN-US>XML</span><span style='font-family:宋体'>数据中找到的所有元素，分别调用这些元素对应的句柄。所以，</span><span
lang=EN-US>lxp_parse</span><span style='font-family:宋体'>会首先为这些句柄准备环境，在调用</span><span
lang=EN-US>XML_Parse</span><span style='font-family:宋体'>的时候有一些细节：记住这个函数的最后一个参数告诉</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>给定的文本段是否是最后一段。当我们不带参数调用他时，</span><span
lang=EN-US>s</span><span style='font-family:宋体'>将使用缺省的</span><span lang=EN-US>NULL</span><span
style='font-family:宋体'>，因此这时候最后一个参数将为</span><span lang=EN-US>true</span><span
style='font-family:宋体'>。现在让我们注意力集中到回调函数</span><span lang=EN-US>f_StartElement</span><span
style='font-family:宋体'>、</span><span lang=EN-US>f_EndElement</span><span
style='font-family:宋体'>和</span><span lang=EN-US>f_CharData</span><span
style='font-family:宋体'>上，这三个函数有相似的结构：每一个都会针对他的指定事件检查</span><span lang=EN-US>callback</span><span
style='font-family:宋体'>表是否定义了</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>句柄，如果有，预处理参数然后调用这个</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>句柄。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>我们首先来看</span><span
lang=EN-US>f_CharData </span><span style='font-family:宋体'>句柄，他的代码非常简单。她调用他对应的</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>中的句柄（当存在的时候），带有两个参数：解析器</span><span
lang=EN-US>parser</span><span style='font-family:宋体'>和字符数据（一个字符串）</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(244,242,224)'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>void</span> f_CharData (<span style='color:blue'>void</span>
*ud, <span style='color:blue'>const</span> <span style='color:blue'>char</span>
*s, <span style='color:blue'>int</span> len) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu = (lxp_userdata *)ud;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,254,246)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_State *L = xpu-&gt;L;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(230,231,250)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* get handler */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushstring(L, <span style='color:red'>&quot;CharacterData&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(241,244,253)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_gettable(L, 3);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>if</span> (lua_isnil(L,
-1)) {&nbsp; <span style='color:green'>/* no handler? */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(254,253,244)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_pop(L, 1);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span>;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(226,234,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,221,247)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushvalue(L, 1); <span style='color:green'>/*
push the parser (`self') */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushlstring(L, s, len);&nbsp; <span
style='color:green'>/* push Char data */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(235,229,220)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_call(L, 2, 0);&nbsp;&nbsp; <span
style='color:green'>/* call the handler */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>注意，由于当我们创建解析器的时候调用了</span><span
lang=EN-US>XML_SetUserData</span><span style='font-family:宋体'>，所以，所有的</span><span
lang=EN-US>C</span><span style='font-family:宋体'>句柄都接受</span><span lang=EN-US>lxp_userdata</span><span
style='font-family:宋体'>数据结构作为第一个参数。还要注意程序是如何使用由</span><span lang=EN-US>lxp_parse</span><span
style='font-family:宋体'>设置的环境的。首先，他假定</span><span lang=EN-US>callback</span><span
style='font-family:宋体'>表在栈中的索引为</span><span lang=EN-US>3</span><span
style='font-family:宋体'>；第二，假定解析器</span><span lang=EN-US>parser</span><span
style='font-family:宋体'>在栈中索引为</span><span lang=EN-US>1</span><span
style='font-family:宋体'>（</span><span lang=EN-US>parser</span><span
style='font-family:宋体'>的位置肯定是这样的，因为她应该是</span><span lang=EN-US>lxp_parse</span><span
style='font-family:宋体'>的第一个参数）。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>f_EndElement</span><span
style='font-family:宋体'>句柄和</span><span lang=EN-US>f_CharData</span><span
style='font-family:宋体'>类似，也很简单。他也是用两个参数调用相应的</span><span lang=EN-US>Lua</span><span
style='font-family:宋体'>句柄：一个解析器</span><span lang=EN-US>parser</span><span
style='font-family:宋体'>和一个标签名（也是一个字符串，但现在是以</span><span lang=EN-US> '\0' </span><span
style='font-family:宋体'>结尾）：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(223,238,222);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>void</span> f_EndElement (<span style='color:blue'>void</span>
*ud, <span style='color:blue'>const</span> <span style='color:blue'>char</span>
*name) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(222,222,255)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu = (lxp_userdata *)ud;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_State *L = xpu-&gt;L;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(249,242,245)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushstring(L, <span style='color:red'>&quot;EndElement&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(220,234,244)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_gettable(L, 3);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>if</span> (lua_isnil(L,
-1)) {&nbsp; <span style='color:green'>/* no handler? */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(243,232,223)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_pop(L, 1);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span>;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(245,254,226)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(248,243,229)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushvalue(L, 1); <span style='color:green'>/*
push the parser (`self') */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushstring(L, name);&nbsp; <span
style='color:green'>/* push tag name */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(229,250,220)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_call(L, 2, 0);&nbsp;&nbsp; <span
style='color:green'>/* call the handler */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>最后一个句柄</span><span
lang=EN-US>f_StartElement</span><span style='font-family:宋体'>带有三个参数：解析器</span><span
lang=EN-US>parser</span><span style='font-family:宋体'>，标签名，和一个属性列表。这个句柄比上面两个稍微复杂点，因为它需要将属性的标签列表翻译成</span><span
lang=EN-US>Lua</span><span style='font-family:宋体'>识别的内容。我们是用自然的翻译方式，比如，类似下面的开始标签：</span></p>

<div style='border:dashed windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(242,247,221);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&lt;to method=<span style='color:red'>&quot;post&quot;</span>
priority=<span style='color:red'>&quot;high&quot;</span>&gt;</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>产生下面的属性表：</span></p>

<div style='border:dashed windowtext 1.0pt;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(247,243,236);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltP style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>{ method = &quot;post&quot;, priority = &quot;high&quot; }</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>f_StartElement</span><span
style='font-family:宋体'>的实现如下：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(247,232,235);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>void</span> f_StartElement (<span style='color:blue'>void</span>
*ud,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,251,246)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='color:blue'>const</span> <span style='color:blue'>char</span> *name,</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span
style='color:blue'>const</span> <span style='color:blue'>char</span> **atts) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,246,244)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu = (lxp_userdata *)ud;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_State *L = xpu-&gt;L;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(234,224,229)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushstring(L, <span style='color:red'>&quot;StartElement&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(221,231,246)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_gettable(L, 3);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>if</span> (lua_isnil(L,
-1)) {&nbsp; <span style='color:green'>/* no handler? */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(249,230,254)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_pop(L, 1);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span>;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(236,243,230)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(230,253,236)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushvalue(L, 1);&nbsp; <span
style='color:green'>/* push the parser (`self') */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushstring(L, name);&nbsp; <span
style='color:green'>/* push tag name */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(233,247,227)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* create and fill the
attribute table */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(236,233,232)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_newtable(L);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>while</span> (*atts) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,234,243)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_pushstring(L, *atts++);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_pushstring(L, *atts++);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,223,236)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lua_settable(L, -3);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(221,230,234)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_call(L, 3, 0);&nbsp; <span style='color:green'>/*
call the handler */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(233,252,222)'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>解析器的最后一个方法是</span><span
lang=EN-US>close</span><span style='font-family:宋体'>。当我们关闭一个解析器的时候，我们必须释放解析器对应的所有资源，即</span><span
lang=EN-US>Expat</span><span style='font-family:宋体'>结构和</span><span lang=EN-US>callback</span><span
style='font-family:宋体'>表。记住，在解析器创建的过程中如果发生错误，解析器并不拥有这些资源：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,233,222)'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>int</span> lxp_close (lua_State *L) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lxp_userdata *xpu;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(250,226,226)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu = (lxp_userdata *)luaL_checkudata(L, 1, <span
style='color:red'>&quot;Expat&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(250,223,231)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_argcheck(L, xpu, 1, <span style='color:red'>&quot;expat
parser expected&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(255,225,247)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* free (unref)
callback table */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_unref(L, LUA_REGISTRYINDEX,
xpu-&gt;tableref);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(254,239,229)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;tableref = LUA_REFNIL;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(232,226,220)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* free Expat parser
(if there is one) */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>if</span>
(xpu-&gt;parser)</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(222,249,239)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XML_ParserFree(xpu-&gt;parser);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; xpu-&gt;parser = NULL;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(226,252,241)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span> 0;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>注意我们在关闭解析器的时候，是如何保证它处于一致的（</span><span
lang=EN-US>consistent</span><span style='font-family:宋体'>）状态的</span><span
lang=EN-US>,</span><span style='font-family:宋体'>当我们对一个已经关闭的解析器或者垃圾收集器已经收集这个解析器之后，再次关闭这个解析器是没有问题的。实际上，我们使用这个函数作为我们的析构函数。他负责保证每一个解析器自动得释放他所有的资源，即使程序员没有关闭解析器。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>最后一步是打开库，将上面各个部分放在一起。这儿我们使用和面向对象的数组例子（</span><span
lang=EN-US>28.3</span><span style='font-family:宋体'>节）一样的方案：创建一个</span><span
lang=EN-US>metatable</span><span style='font-family:宋体'>，将所有的方法放在这个表内，表的</span><span
lang=EN-US>__index</span><span style='font-family:宋体'>域指向自己。这样，我们还需要一个解析器方法的列表：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(225,228,241);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>const</span> <span style='color:blue'>struct</span> luaL_reg
lxp_meths[] = {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(245,242,252)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {<span style='color:red'>&quot;parse&quot;</span>,
lxp_parse},</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {<span style='color:red'>&quot;close&quot;</span>,
lxp_close},</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(237,241,221)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {<span style='color:red'>&quot;__gc&quot;</span>,
lxp_close},</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {NULL, NULL}</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(233,236,228)'><span
lang=EN-US>};</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>我们也需要一个关于这个库中所有函数的列表。和</span><span
lang=EN-US>OO</span><span style='font-family:宋体'>库相同的是，这个库只有一个函数，这个函数负责创建一个新的解析器：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:#fff;margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(255,234,248)'><span
lang=EN-US style='color:blue'>static</span><span lang=EN-US> <span
style='color:blue'>const</span> <span style='color:blue'>struct</span> luaL_reg
lxp_funcs[] = {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {<span style='color:red'>&quot;new&quot;</span>,
lxp_make_parser},</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(223,240,227)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; {NULL, NULL}</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>};</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>最终，</span><span
lang=EN-US>open</span><span style='font-family:宋体'>函数必须要创建</span><span
lang=EN-US>metatable</span><span style='font-family:宋体'>，并通过</span><span
lang=EN-US>__index</span><span style='font-family:宋体'>指向表本身，并且注册方法和函数：</span></p>

<div style='border:RGB(104,197,100) dashed 1px;padding:1.0pt 4.0pt 1.0pt 4.0pt;
background:RGB(233,224,233);margin-left:21.0pt;margin-right:21.0pt'>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US style='color:blue'>int</span><span lang=EN-US> luaopen_lxp
(lua_State *L) {</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(237,240,249)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* create metatable */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_newmetatable(L, <span style='color:red'>&quot;Expat&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(238,236,225)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* metatable.__index =
metatable */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(225,239,250)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushliteral(L, <span style='color:red'>&quot;__index&quot;</span>);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_pushvalue(L, -2);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(239,239,241)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; lua_rawset(L, -3);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(252,238,220)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* register methods */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_openlib (L, NULL, lxp_meths, 0);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(228,230,236)'><span
lang=EN-US>&nbsp;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:green'>/* register functions
(only lxp.new) */</span></span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(220,240,229)'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; luaL_openlib (L, <span style='color:red'>&quot;lxp&quot;</span>,
lxp_funcs, 0);</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:#fff'><span
lang=EN-US>&nbsp;&nbsp;&nbsp; <span style='color:blue'>return</span> 1;</span></p>

<p class=AltD style='margin:0cm;margin-bottom:.0001pt;background:RGB(227,238,226)'><span
lang=EN-US>}</span></p>

</div>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

</div>

<span lang=EN-US style='font-size:10.5pt;font-family:"Times New Roman","serif"'><br
clear=all style='page-break-before:always'>
</span>

<div class=Section40 style='layout-grid:15.6pt 0pt'>


</div>
  <p></p>
  <hr class="moHR" />
  <span class="moCopyright">
    相关链接：
<br /><a href="_3.htm">lua程序设计目录</a> - <a href="http://www.luaer.cn">中国lua开发者</a> - <a href="http://bbs.luaer.cn">lua论坛</a> 
  </span><div id="bookfoot"></div>
<script language="JavaScript" src="js/ad.js"></script>
</body>

</html>

